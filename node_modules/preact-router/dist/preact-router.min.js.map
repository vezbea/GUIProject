{"version":3,"sources":["../src/util.js","../src/index.js"],"names":["exec","url","route","opts","arguments","length","undefined","EMPTY","reg","c","match","matches","ret","p","split","i","r","decodeURIComponent","slice","join","segmentize","replace","max","Math","charAt","param","flags","plus","indexOf","star","val","map","default","pathRankSort","a","b","aAttr","attributes","bAttr","diff","rank","path","strip","isPreactElement","node","ATTR_KEY","setUrl","type","customHistory","history","getCurrentUrl","location","getCurrentLocation","pathname","search","canRoute","routeTo","ROUTERS","didRoute","routeFromLink","getAttribute","href","target","handleLinkClick","e","button","currentTarget","this","prevent","stopImmediatePropagation","stopPropagation","preventDefault","delegateLinkHandler","ctrlKey","metaKey","altKey","shiftKey","t","String","nodeName","toUpperCase","parentNode","initEventListeners","eventListenersInitialized","addEventListener","Symbol","for","Link","props","h","_extends","onClick","Router","_Component","call","state","_this","shouldComponentUpdate","static","onChange","getMatchingChildren","children","_didRoute","setState","updating","forceUpdate","componentWillMount","push","componentDidMount","unlisten","listen","componentWillUnmount","splice","componentWillUpdate","componentDidUpdate","invoke","sort","filter","_ref","hasOwnProperty","render","_ref2","_ref3","active","current","previous","previousUrl","Component","Route","_ref4","component"],"mappings":"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","file":"preact-router.min.js","sourcesContent":["\nconst EMPTY = {};\n\nexport function exec(url, route, opts=EMPTY) {\n\tlet reg = /(?:\\?([^#]*))?(#.*)?$/,\n\t\tc = url.match(reg),\n\t\tmatches = {},\n\t\tret;\n\tif (c && c[1]) {\n\t\tlet p = c[1].split('&');\n\t\tfor (let i=0; i<p.length; i++) {\n\t\t\tlet r = p[i].split('=');\n\t\t\tmatches[decodeURIComponent(r[0])] = decodeURIComponent(r.slice(1).join('='));\n\t\t}\n\t}\n\turl = segmentize(url.replace(reg, ''));\n\troute = segmentize(route || '');\n\tlet max = Math.max(url.length, route.length);\n\tfor (let i=0; i<max; i++) {\n\t\tif (route[i] && route[i].charAt(0)===':') {\n\t\t\tlet param = route[i].replace(/(^\\:|[+*?]+$)/g, ''),\n\t\t\t\tflags = (route[i].match(/[+*?]+$/) || EMPTY)[0] || '',\n\t\t\t\tplus = ~flags.indexOf('+'),\n\t\t\t\tstar = ~flags.indexOf('*'),\n\t\t\t\tval = url[i] || '';\n\t\t\tif (!val && !star && (flags.indexOf('?')<0 || plus)) {\n\t\t\t\tret = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmatches[param] = decodeURIComponent(val);\n\t\t\tif (plus || star) {\n\t\t\t\tmatches[param] = url.slice(i).map(decodeURIComponent).join('/');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse if (route[i]!==url[i]) {\n\t\t\tret = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (opts.default!==true && ret===false) return false;\n\treturn matches;\n}\n\nexport function pathRankSort(a, b) {\n\tlet aAttr = a.attributes || EMPTY,\n\t\tbAttr = b.attributes || EMPTY;\n\tif (aAttr.default) return 1;\n\tif (bAttr.default) return -1;\n\tlet diff = rank(aAttr.path) - rank(bAttr.path);\n\treturn diff || (aAttr.path.length - bAttr.path.length);\n}\n\nexport function segmentize(url) {\n\treturn strip(url).split('/');\n}\n\nexport function rank(url) {\n\treturn (strip(url).match(/\\/+/g) || '').length;\n}\n\nexport function strip(url) {\n\treturn url.replace(/(^\\/+|\\/+$)/g, '');\n}\n","import { h, Component } from 'preact';\nimport { exec, pathRankSort } from './util';\n\nlet customHistory = null;\n\nconst ROUTERS = [];\n\nconst EMPTY = {};\n\n// hangs off all elements created by preact\nconst ATTR_KEY = typeof Symbol!=='undefined' ? Symbol.for('preactattr') : '__preactattr_';\n\n\nfunction isPreactElement(node) {\n\treturn ATTR_KEY in node;\n}\n\nfunction setUrl(url, type='push') {\n\tif (customHistory && customHistory[type]) {\n\t\tcustomHistory[type](url);\n\t}\n\telse if (typeof history!=='undefined' && history[type+'State']) {\n\t\thistory[type+'State'](null, null, url);\n\t}\n}\n\n\nfunction getCurrentUrl() {\n\tlet url;\n\tif (customHistory && customHistory.location) {\n\t\turl = customHistory.location;\n\t}\n\telse if (customHistory && customHistory.getCurrentLocation) {\n\t\turl = customHistory.getCurrentLocation();\n\t}\n\telse {\n\t\turl = typeof location!=='undefined' ? location : EMPTY;\n\t}\n\treturn `${url.pathname || ''}${url.search || ''}`;\n}\n\n\nfunction route(url, replace=false) {\n\tif (typeof url!=='string' && url.url) {\n\t\treplace = url.replace;\n\t\turl = url.url;\n\t}\n\n\t// only push URL into history if we can handle it\n\tif (canRoute(url)) {\n\t\tsetUrl(url, replace ? 'replace' : 'push');\n\t}\n\n\treturn routeTo(url);\n}\n\n\n/** Check if the given URL can be handled by any router instances. */\nfunction canRoute(url) {\n\tfor (let i=ROUTERS.length; i--; ) {\n\t\tif (ROUTERS[i].canRoute(url)) return true;\n\t}\n\treturn false;\n}\n\n\n/** Tell all router instances to handle the given URL.  */\nfunction routeTo(url) {\n\tlet didRoute = false;\n\tfor (let i=0; i<ROUTERS.length; i++) {\n\t\tif (ROUTERS[i].routeTo(url)===true) {\n\t\t\tdidRoute = true;\n\t\t}\n\t}\n\treturn didRoute;\n}\n\n\nfunction routeFromLink(node) {\n\t// only valid elements\n\tif (!node || !node.getAttribute) return;\n\n\tlet href = node.getAttribute('href'),\n\t\ttarget = node.getAttribute('target');\n\n\t// ignore links with targets and non-path URLs\n\tif (!href || !href.match(/^\\//g) || (target && !target.match(/^_?self$/i))) return;\n\n\t// attempt to route, if no match simply cede control to browser\n\treturn route(href);\n}\n\n\nfunction handleLinkClick(e) {\n\tif (e.button !== 0) return;\n\trouteFromLink(e.currentTarget || e.target || this);\n\treturn prevent(e);\n}\n\n\nfunction prevent(e) {\n\tif (e) {\n\t\tif (e.stopImmediatePropagation) e.stopImmediatePropagation();\n\t\tif (e.stopPropagation) e.stopPropagation();\n\t\te.preventDefault();\n\t}\n\treturn false;\n}\n\n\nfunction delegateLinkHandler(e) {\n\t// ignore events the browser takes care of already:\n\tif (e.ctrlKey || e.metaKey || e.altKey || e.shiftKey) return;\n\n\tlet t = e.target;\n\tdo {\n\t\tif (String(t.nodeName).toUpperCase()==='A' && t.getAttribute('href') && isPreactElement(t)) {\n\t\t\tif (e.button !== 0) return;\n\t\t\t// if link is handled by the router, prevent browser defaults\n\t\t\tif (routeFromLink(t)) {\n\t\t\t\treturn prevent(e);\n\t\t\t}\n\t\t}\n\t} while ((t=t.parentNode));\n}\n\n\nlet eventListenersInitialized = false;\n\nfunction initEventListeners() {\n\tif (eventListenersInitialized){\n\t\treturn;\n\t}\n\n\tif (typeof addEventListener==='function') {\n\t\tif (!customHistory) {\n\t\t\taddEventListener('popstate', () => routeTo(getCurrentUrl()));\n\t\t}\n\t\taddEventListener('click', delegateLinkHandler);\n\t}\n\teventListenersInitialized = true;\n}\n\n\nconst Link = (props) => {\n\treturn h('a', Object.assign({}, props, { onClick: handleLinkClick }));\n};\n\n\nclass Router extends Component {\n\tconstructor(props) {\n\t\tsuper(props);\n\t\tif (props.history) {\n\t\t\tcustomHistory = props.history;\n\t\t}\n\n\t\tthis.state = {\n\t\t\turl: this.props.url || getCurrentUrl()\n\t\t};\n\n\t\tinitEventListeners();\n\t}\n\n\tshouldComponentUpdate(props) {\n\t\tif (props.static!==true) return true;\n\t\treturn props.url!==this.props.url || props.onChange!==this.props.onChange;\n\t}\n\n\t/** Check if the given URL can be matched against any children */\n\tcanRoute(url) {\n\t\treturn this.getMatchingChildren(this.props.children, url, false).length > 0;\n\t}\n\n\t/** Re-render children with a new URL to match against. */\n\trouteTo(url) {\n\t\tthis._didRoute = false;\n\t\tthis.setState({ url });\n\n\t\t// if we're in the middle of an update, don't synchronously re-route.\n\t\tif (this.updating) return this.canRoute(url);\n\n\t\tthis.forceUpdate();\n\t\treturn this._didRoute;\n\t}\n\n\tcomponentWillMount() {\n\t\tROUTERS.push(this);\n\t\tthis.updating = true;\n\t}\n\n\tcomponentDidMount() {\n\t\tif (customHistory) {\n\t\t\tthis.unlisten = customHistory.listen((location) => {\n\t\t\t\tthis.routeTo(`${location.pathname || ''}${location.search || ''}`);\n\t\t\t});\n\t\t}\n\t\tthis.updating = false;\n\t}\n\n\tcomponentWillUnmount() {\n\t\tif (typeof this.unlisten==='function') this.unlisten();\n\t\tROUTERS.splice(ROUTERS.indexOf(this), 1);\n\t}\n\n\tcomponentWillUpdate() {\n\t\tthis.updating = true;\n\t}\n\n\tcomponentDidUpdate() {\n\t\tthis.updating = false;\n\t}\n\n\tgetMatchingChildren(children, url, invoke) {\n\t\treturn children.slice().sort(pathRankSort).filter( ({ attributes }) => {\n\t\t\tlet path = attributes.path,\n\t\t\t\tmatches = exec(url, path, attributes);\n\t\t\tif (matches) {\n\t\t\t\tif (invoke!==false) {\n\t\t\t\t\tattributes.url = url;\n\t\t\t\t\tattributes.matches = matches;\n\t\t\t\t\t// copy matches onto props\n\t\t\t\t\tfor (let i in matches) {\n\t\t\t\t\t\tif (matches.hasOwnProperty(i)) {\n\t\t\t\t\t\t\tattributes[i] = matches[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\t}\n\n\trender({ children, onChange }, { url }) {\n\t\tlet active = this.getMatchingChildren(children, url, true);\n\n\t\tlet current = active[0] || null;\n\t\tthis._didRoute = !!current;\n\n\t\tlet previous = this.previousUrl;\n\t\tif (url!==previous) {\n\t\t\tthis.previousUrl = url;\n\t\t\tif (typeof onChange==='function') {\n\t\t\t\tonChange({\n\t\t\t\t\trouter: this,\n\t\t\t\t\turl,\n\t\t\t\t\tprevious,\n\t\t\t\t\tactive,\n\t\t\t\t\tcurrent\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn current;\n\t}\n}\n\n\nconst Route = ({ component, url, matches }) => {\n\treturn h(component, { url, matches });\n};\n\n\nRouter.route = route;\nRouter.Router = Router;\nRouter.Route = Route;\nRouter.Link = Link;\n\nexport { route, Router, Route, Link };\nexport default Router;\n"]}